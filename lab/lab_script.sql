--------------------------------------------------------------------------------
-- FILM PRODUCTION & CREW MANAGEMENT SYSTEM (Oracle 19c)
-- SQL Script for Practical Lab - Advanced Database
-- Author: Frank Ricardo (Reg. No: 216128218)
--------------------------------------------------------------------------------

-- CLEANUP
BEGIN EXECUTE IMMEDIATE 'DROP VIEW VW_FILM_COST_BREAKDOWN'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN
FOR t IN (SELECT table_name FROM user_tables) LOOP
            EXECUTE IMMEDIATE 'DROP TABLE ' || t.table_name || ' CASCADE CONSTRAINTS';
END LOOP;
END;
/
BEGIN
FOR tr IN (SELECT trigger_name FROM user_triggers) LOOP
            EXECUTE IMMEDIATE 'DROP TRIGGER ' || tr.trigger_name;
END LOOP;
END;
/
--------------------------------------------------------------------------------
-- TABLE CREATION
--------------------------------------------------------------------------------
CREATE TABLE Project (
                         ProjectID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                         Title VARCHAR2(200) NOT NULL,
                         Director VARCHAR2(150),
                         StartDate DATE NOT NULL,
                         EndDate DATE,
                         Budget NUMBER(14,2) DEFAULT 0 NOT NULL,
                         CONSTRAINT CK_PRJ_DATES CHECK (EndDate IS NULL OR EndDate >= StartDate),
                         CONSTRAINT CK_PRJ_BUDGET CHECK (Budget >= 0)
);

CREATE TABLE Crew (
                      CrewID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                      FullName VARCHAR2(150) NOT NULL,
                      Role VARCHAR2(100) NOT NULL,
                      Contact VARCHAR2(120),
                      ExperienceYears NUMBER(2) DEFAULT 0 NOT NULL,
                      CONSTRAINT CK_CREW_EXP CHECK (ExperienceYears >= 0)
);

CREATE TABLE Assignment (
                            AssignID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                            ProjectID NUMBER NOT NULL REFERENCES Project(ProjectID),
                            CrewID NUMBER NOT NULL REFERENCES Crew(CrewID),
                            StartDate DATE NOT NULL,
                            EndDate DATE,
                            DailyRate NUMBER(12,2) DEFAULT 0 NOT NULL,
                            CONSTRAINT CK_ASS_DATES CHECK (EndDate IS NULL OR EndDate >= StartDate),
                            CONSTRAINT CK_ASS_RATE CHECK (DailyRate >= 0)
);

CREATE TABLE Schedule (
                          ScheduleID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                          ProjectID NUMBER NOT NULL REFERENCES Project(ProjectID),
                          Scene VARCHAR2(200) NOT NULL,
                          Location VARCHAR2(200),
                          ShootDate DATE NOT NULL,
                          Status VARCHAR2(30) DEFAULT 'Planned' NOT NULL,
                          CONSTRAINT CK_SCH_STATUS CHECK (Status IN ('Planned','Shooting','Done','Cancelled'))
);

CREATE TABLE Expense (
                         ExpenseID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                         ProjectID NUMBER NOT NULL REFERENCES Project(ProjectID),
                         Description VARCHAR2(300) NOT NULL,
                         Amount NUMBER(14,2) NOT NULL CHECK (Amount > 0),
                         DateIncurred DATE DEFAULT SYSDATE NOT NULL
);

CREATE TABLE Payment (
                         PaymentID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                         AssignID NUMBER NOT NULL REFERENCES Assignment(AssignID) ON DELETE CASCADE,
                         Amount NUMBER(14,2) NOT NULL CHECK (Amount > 0),
                         PaymentDate DATE DEFAULT SYSDATE NOT NULL,
                         Method VARCHAR2(40) DEFAULT 'Bank' NOT NULL
);

--------------------------------------------------------------------------------
-- TRIGGERS
--------------------------------------------------------------------------------
CREATE OR REPLACE TRIGGER TRG_EXPENSE_UPDATE_BUDGET
    BEFORE INSERT ON Expense
    FOR EACH ROW
DECLARE
v_budget NUMBER;
BEGIN
SELECT Budget INTO v_budget FROM Project WHERE ProjectID = :NEW.ProjectID FOR UPDATE;
IF v_budget - :NEW.Amount < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Expense exceeds remaining project budget.');
END IF;
UPDATE Project SET Budget = Budget - :NEW.Amount WHERE ProjectID = :NEW.ProjectID;
END;
/
CREATE OR REPLACE TRIGGER TRG_PAYMENT_BUDGET_GUARD
    BEFORE INSERT ON Payment
    FOR EACH ROW
DECLARE
v_project_id NUMBER;
    v_remaining NUMBER;
BEGIN
SELECT ProjectID INTO v_project_id FROM Assignment WHERE AssignID = :NEW.AssignID;
SELECT Budget INTO v_remaining FROM Project WHERE ProjectID = v_project_id FOR UPDATE;
IF :NEW.Amount > v_remaining THEN
        RAISE_APPLICATION_ERROR(-20002, 'Payment exceeds remaining project budget.');
END IF;
UPDATE Project SET Budget = Budget - :NEW.Amount WHERE ProjectID = v_project_id;
END;
/
--------------------------------------------------------------------------------
-- VIEW
--------------------------------------------------------------------------------
CREATE OR REPLACE VIEW VW_FILM_COST_BREAKDOWN AS
WITH ass_cost AS (
    SELECT a.ProjectID,
           SUM((NVL(a.EndDate, a.StartDate) - a.StartDate + 1) * a.DailyRate) AS total_assignment_cost
    FROM Assignment a GROUP BY a.ProjectID
),
     exp_cost AS (
         SELECT ProjectID, SUM(Amount) AS total_expenses FROM Expense GROUP BY ProjectID
     ),
     pay_cost AS (
         SELECT a.ProjectID, SUM(p.Amount) AS total_payments
         FROM Payment p JOIN Assignment a ON a.AssignID = p.AssignID
         GROUP BY a.ProjectID
     )
SELECT p.ProjectID, p.Title,
       NVL(ac.total_assignment_cost,0) AS total_assignment_cost,
       NVL(ec.total_expenses,0) AS total_expenses,
       NVL(pc.total_payments,0) AS total_payments,
       p.Budget AS remaining_budget
FROM Project p
         LEFT JOIN ass_cost ac ON ac.ProjectID = p.ProjectID
         LEFT JOIN exp_cost ec ON ec.ProjectID = p.ProjectID
         LEFT JOIN pay_cost pc ON pc.ProjectID = p.ProjectID;
/
--------------------------------------------------------------------------------
-- SAMPLE DATA INSERTS
--------------------------------------------------------------------------------

------------------------------------------------------
-- 3 Projects, 10 Crew (minimal set)
------------------------------------------------------
-- Projects
INSERT INTO Project (Title, Director, StartDate, EndDate, Budget)
VALUES ('Echoes of Kigali', 'A. Niyonsenga', DATE '2025-01-15', NULL, 200000);

INSERT INTO Project (Title, Director, StartDate, EndDate, Budget)
VALUES ('Hills of Rwanda', 'M. Uwase', DATE '2025-02-01', NULL, 150000);

INSERT INTO Project (Title, Director, StartDate, EndDate, Budget)
VALUES ('Lake Kivu Shadows', 'K. Habimana', DATE '2025-03-10', NULL, 180000);

-- Crew (10 members)
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('John Doe','Cinematographer','john@example.com',7);
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('Alice Muhire','Director Assistant','alice@example.com',4);
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('Peter Kim','Sound Engineer','peter@example.com',6);
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('Diane Umuhoza','Makeup Artist','diane@example.com',5);
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('Eric Ndayisaba','Gaffer','eric@example.com',3);
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('Sara Uwimana','Editor','sara@example.com',8);
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('Paul Mugisha','Production Designer','paul@example.com',6);
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('Lena Uwera','Script Supervisor','lena@example.com',4);
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('Ivan Habineza','Stunt Coordinator','ivan@example.com',9);
INSERT INTO Crew (FullName, Role, Contact, ExperienceYears) VALUES ('Chantal Umutesi','Costume Designer','chantal@example.com',5);

COMMIT;

--------------------------------------------------------------------------------
-- Assign some crew to projects (for payments & queries)
-------------------------------------------------------------
INSERT INTO Assignment (ProjectID, CrewID, StartDate, EndDate, DailyRate)
SELECT p.ProjectID, c.CrewID, DATE '2025-01-16', DATE '2025-01-30', 250
FROM Project p CROSS JOIN (SELECT CrewID FROM Crew WHERE CrewID <= 3) c
WHERE p.Title = 'Echoes of Kigali';

INSERT INTO Assignment (ProjectID, CrewID, StartDate, EndDate, DailyRate)
SELECT p.ProjectID, c.CrewID, DATE '2025-02-05', DATE '2025-02-20', 300
FROM Project p CROSS JOIN (SELECT CrewID FROM Crew WHERE CrewID BETWEEN 4 AND 6) c
WHERE p.Title = 'Hills of Rwanda';

INSERT INTO Assignment (ProjectID, CrewID, StartDate, EndDate, DailyRate)
SELECT p.ProjectID, c.CrewID, DATE '2025-03-12', DATE '2025-03-25', 280
FROM Project p CROSS JOIN (SELECT CrewID FROM Crew WHERE CrewID BETWEEN 7 AND 10) c
WHERE p.Title = 'Lake Kivu Shadows';

INSERT INTO Assignment (ProjectID, CrewID, StartDate, EndDate, DailyRate)
SELECT p.ProjectID, c.CrewID, DATE '2025-03-12', DATE '2025-03-25', 280
FROM Project p CROSS JOIN (SELECT CrewID FROM Crew WHERE CrewID BETWEEN 1 AND 10) c
WHERE p.Title = 'Lake Kivu Shadows';


COMMIT;
-------------------------------------------
--Schedules (just a few sample rows)
-------------------------------------------
INSERT INTO Schedule (ProjectID, Scene, Location, ShootDate, Status)
SELECT ProjectID, 'Opening Market', 'Kigali CBD', DATE '2025-01-20', 'Planned'
FROM Project WHERE Title='Echoes of Kigali';

INSERT INTO Schedule (ProjectID, Scene, Location, ShootDate, Status)
SELECT ProjectID, 'Hillside Sunrise', 'Northern Province', DATE '2025-02-10', 'Planned'
FROM Project WHERE Title='Hills of Rwanda';

INSERT INTO Schedule (ProjectID, Scene, Location, ShootDate, Status)
SELECT ProjectID, 'Lake Dock', 'Rubavu', DATE '2025-03-18', 'Planned'
FROM Project WHERE Title='Lake Kivu Shadows';

COMMIT;

---------------------------------
-- Expenses (for each film)
---------------------------------
INSERT INTO Expense (ProjectID, Description, Amount, DateIncurred)
SELECT ProjectID, 'Equipment rental', 12000, SYSDATE FROM Project WHERE Title='Echoes of Kigali';

INSERT INTO Expense (ProjectID, Description, Amount, DateIncurred)
SELECT ProjectID, 'Location permits', 8000, SYSDATE FROM Project WHERE Title='Hills of Rwanda';

INSERT INTO Expense (ProjectID, Description, Amount, DateIncurred)
SELECT ProjectID, 'Props & wardrobe', 9500, SYSDATE FROM Project WHERE Title='Lake Kivu Shadows';

COMMIT;

------------------------------------------------------------------------
--Total expenses per film project (GROUP BY)
------------------------------------------------------------------------
SELECT p.ProjectID, p.Title,
       NVL(SUM(e.Amount),0) AS Total_Expenses
FROM Project p
         LEFT JOIN Expense e ON e.ProjectID = p.ProjectID
GROUP BY p.ProjectID, p.Title
ORDER BY p.ProjectID;

-------------------------------------------------------------------------------------
-- Update project budget after each expense
-- Approach: BEFORE INSERT on Expense will decrement Project.Budget by :NEW.Amount
-------------------------------------------------------------------------------------
CREATE OR REPLACE TRIGGER TRG_EXPENSE_UPDATE_BUDGET
    BEFORE INSERT ON Expense
    FOR EACH ROW
DECLARE
v_budget NUMBER;
BEGIN
    -- Fetch current budget
SELECT Budget INTO v_budget FROM Project WHERE ProjectID = :NEW.ProjectID FOR UPDATE;

IF v_budget - :NEW.Amount < 0 THEN
        -- Allow expense but budget can go negative? The task says "update budget"; we enforce non-negative:
        RAISE_APPLICATION_ERROR(-20001, 'Expense exceeds remaining project budget.');
END IF;

    -- Decrement project budget (treat Budget as RemainingBudget)
UPDATE Project SET Budget = Budget - :NEW.Amount
WHERE ProjectID = :NEW.ProjectID;
END;
/

-- Test insert that would fail if it exceeds budget:
INSERT INTO Expense(ProjectID, Description, Amount) VALUES (1, 'Overrun', 9999999);

-------------------------------------------------------------------------------------------
-- Identify crew who worked on multiple projects (DISTINCT COUNT > 1)
-------------------------------------------------------------------------------------------
SELECT c.CrewID, c.FullName,
       COUNT(DISTINCT a.ProjectID) AS Projects_Worked
FROM Crew c
         JOIN Assignment a ON a.CrewID = c.CrewID
GROUP BY c.CrewID, c.FullName
HAVING COUNT(DISTINCT a.ProjectID) > 1
ORDER BY Projects_Worked DESC, c.FullName;

-----------------------------------------------------------------------------------------
--View – Cost breakdown by film
-- Includes:
--   * Total Assignment Cost (days * rate)
--   * Total Expenses
--   * Total Payments
--   * Remaining Budget (current Project.Budget if using decrement model)
-----------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW VW_FILM_COST_BREAKDOWN AS
WITH ass_cost AS (
    SELECT a.ProjectID,
           SUM( (NVL(a.EndDate, a.StartDate) - a.StartDate + 1) * a.DailyRate ) AS total_assignment_cost
    FROM Assignment a
    GROUP BY a.ProjectID
),
     exp_cost AS (
         SELECT ProjectID, SUM(Amount) AS total_expenses
         FROM Expense
         GROUP BY ProjectID
     ),
     pay_cost AS (
         SELECT a.ProjectID, SUM(p.Amount) AS total_payments
         FROM Payment p
                  JOIN Assignment a ON a.AssignID = p.AssignID
         GROUP BY a.ProjectID
     )
SELECT p.ProjectID, p.Title,
       NVL(ac.total_assignment_cost,0) AS total_assignment_cost,
       NVL(ec.total_expenses,0)       AS total_expenses,
       NVL(pc.total_payments,0)       AS total_payments,
       p.Budget                        AS remaining_budget
FROM Project p
         LEFT JOIN ass_cost ac ON ac.ProjectID = p.ProjectID
         LEFT JOIN exp_cost ec ON ec.ProjectID = p.ProjectID
         LEFT JOIN pay_cost pc ON pc.ProjectID = p.ProjectID;

-- Quick check
SELECT * FROM VW_FILM_COST_BREAKDOWN ORDER BY ProjectID;
---------------------------------------------------------------------------------------------
--Trigger preventing PAYMENT if project budget exceeded
---------------------------------------------------------------------------------------------
CREATE OR REPLACE TRIGGER TRG_PAYMENT_BUDGET_GUARD
    BEFORE INSERT ON Payment
    FOR EACH ROW
DECLARE
v_project_id   NUMBER;
    v_remaining    NUMBER;
BEGIN
    -- Resolve the project of the assignment
SELECT ProjectID INTO v_project_id FROM Assignment WHERE AssignID = :NEW.AssignID;

-- Remaining budget is current Project.Budget (because earlier trigger decremented it by expenses)
SELECT Budget INTO v_remaining FROM Project WHERE ProjectID = v_project_id FOR UPDATE;

IF :NEW.Amount > v_remaining THEN
        RAISE_APPLICATION_ERROR(-20002, 'Payment would exceed remaining project budget.');
END IF;

    -- If allowed, decrement remaining budget by the payment amount as well
UPDATE Project SET Budget = Budget - :NEW.Amount WHERE ProjectID = v_project_id;
END;
/
-- Test insert payment:
INSERT INTO Payment(AssignID, Amount, Method) VALUES (1, 5000, 'Bank');
COMMIT;
-- END OF MAIN SCHEMA SCRIPT

--------------------------------------------------------------------------------
-- Parallel and Distributed Databases queries
--------------------------------------------------------------------------------

-----------------------------------------------------------
-- Create two users/schemas (DBA step; run as SYS or DBA)
-----------------------------------------------------------
-- DROP USER BranchDB_A CASCADE;
-- DROP USER BranchDB_B CASCADE;

CREATE USER BranchDB_A IDENTIFIED BY "A_pwd" QUOTA UNLIMITED ON USERS;
GRANT CONNECT, RESOURCE, CREATE VIEW, CREATE SYNONYM, CREATE DATABASE LINK TO BranchDB_A;

CREATE USER BranchDB_B IDENTIFIED BY "B_pwd" QUOTA UNLIMITED ON USERS;
GRANT CONNECT, RESOURCE, CREATE VIEW, CREATE SYNONYM, CREATE DATABASE LINK TO BranchDB_B;

--grant access to BranchDB_A
GRANT SELECT ON Project TO BranchDB_A;
GRANT SELECT ON Crew TO BranchDB_A;
--grant access to BranchDB_B
GRANT SELECT ON Project TO BranchDB_B;
GRANT SELECT ON Crew TO BranchDB_B;
-----------------------------------------------------------
-- In BranchDB_A: create horizontal fragments (e.g., odd IDs)
-----------------------------------------------------------
-- CONNECT BranchDB_A/A_pwd
-- Minimal subset: Project_A, Crew_A, etc. (demo)

CREATE TABLE Project_A AS SELECT * FROM Project WHERE MOD(ProjectID,2)=1;
CREATE TABLE Crew_A    AS SELECT * FROM Crew    WHERE MOD(CrewID,2)=1;

-----------------------------------------------------------
-- In BranchDB_B: even IDs
-----------------------------------------------------------
-- CONNECT BranchDB_B/B_pwd
CREATE TABLE Project_B AS SELECT * FROM Project WHERE MOD(ProjectID,2)=0;
CREATE TABLE Crew_B    AS SELECT * FROM Crew    WHERE MOD(CrewID,2)=0;

-----------------------------------------------------------
-- Create & Use Database Links + Distributed Join
-----------------------------------------------------------
GRANT CREATE SESSION TO BranchDB_B;
GRANT CREATE SESSION TO BranchDB_A;

-- From BranchDB_A, create a link to BranchDB_B (adjust host/service)
-- CONNECT BranchDB_A/A_pwd



CREATE DATABASE LINK DBLINK_TO_B
    CONNECT TO BranchDB_B IDENTIFIED BY "B_pwd"
    USING '//localhost:1521/XE';

-- Test remote SELECT
SELECT COUNT(*) AS project_rows_in_B FROM Project_B@DBLINK_TO_B;

-- Distributed JOIN: projects from A with crew from B
SELECT a.ProjectID, a.Title, b.CrewID
FROM Project_A a
         JOIN Crew_B@DBLINK_TO_B b ON 1=1
WHERE a.ProjectID IS NOT NULL
    FETCH FIRST 10 ROWS ONLY;

-----------------------------------------------------------
-- Parallel Query Execution
-----------------------------------------------------------

-- Create a large table quickly by multiplying Schedule rows
CREATE TABLE BIG_SCHEDULE AS SELECT * FROM Schedule;

INSERT /*+ APPEND */ INTO BIG_SCHEDULE SELECT * FROM BIG_SCHEDULE; -- x2
COMMIT;

INSERT /*+ APPEND */ INTO BIG_SCHEDULE SELECT * FROM BIG_SCHEDULE; -- x4
COMMIT;

INSERT /*+ APPEND */ INTO BIG_SCHEDULE SELECT * FROM BIG_SCHEDULE; -- x8
COMMIT;

-- Gather stats (improves plan accuracy)
BEGIN DBMS_STATS.GATHER_TABLE_STATS(USER,'BIG_SCHEDULE'); END;
/

-- Serial vs Parallel scan
EXPLAIN PLAN FOR SELECT /*+ FULL(bs) */ COUNT(*) FROM BIG_SCHEDULE bs;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR SELECT /*+ PARALLEL(bs, 8) */ COUNT(*) FROM BIG_SCHEDULE bs;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-----------------------------------------------------------
-- 4. Two-Phase Commit Simulation
-----------------------------------------------------------
-- From BranchDB_A, insert locally and remotely in one transaction, then COMMIT.
-- CONNECT BranchDB_A/A_pwd
SET TRANSACTION READ WRITE;

INSERT INTO Project_A (ProjectID, Title, Director, StartDate, EndDate, Budget)
VALUES (999001, 'Distributed Test A', 'Dir A', SYSDATE, NULL, 10000);

INSERT INTO Project_B@DBLINK_TO_B (ProjectID, Title, Director, StartDate, EndDate, Budget)
VALUES (999002, 'Distributed Test B', 'Dir B', SYSDATE, NULL, 12000);

COMMIT;

-- Verify atomicity via DBA_2PC_PENDING (requires DBA view privilege)
-- SELECT * FROM DBA_2PC_PENDING WHERE LOCAL_TRAN_ID LIKE '%';

-----------------------------------------------------------
-- 5. Distributed Rollback & Recovery
-----------------------------------------------------------

-- Start a distributed transaction
UPDATE Project_A SET Budget = Budget + 1 WHERE ProjectID = 999001;
UPDATE Project_B@DBLINK_TO_B SET Budget = Budget + 1 WHERE ProjectID = 999002;

-- Now break the link (simulate network issue) before COMMIT (e.g., stop listener)
-- Then attempt COMMIT; if in-doubt, check pending:
-- SELECT LOCAL_TRAN_ID, STATE FROM DBA_2PC_PENDING;

-- Force rollback when stuck (run as DBA):
-- ROLLBACK FORCE 'local_tran_id_from_view';


-----------------------------------------------------------
-- 6. Distributed Concurrency Control (Lock Conflict)
-----------------------------------------------------------
-- open Session A (BranchDB_A):
UPDATE Project_A SET Title = Title || ' *' WHERE ProjectID = 999001;

-- Session B (BranchDB_B via link back to A, or touch same logical entity depending on your fragmentation model)
-- If you map synonyms so both can see the same row via a link, do:
-- UPDATE Project_A@DBLINK_TO_A SET Title = Title || ' #'
-- WHERE ProjectID = 999001;

-- In B, the statement should block. Query locks:
SELECT * FROM V$LOCK WHERE BLOCK != 0;  -- DBA view
-- Or friendlier:
SELECT l.session_id, l.locked_mode, o.object_name
FROM V$LOCKED_OBJECT l JOIN DBA_OBJECTS o ON o.object_id = l.object_id;

-----------------------------------------------------------
-- 7. Parallel Data Loading / ETL Simulation (PARALLEL DML)
-----------------------------------------------------------

-- Enable parallel DML for this session
ALTER SESSION ENABLE PARALLEL DML;

-- Example: aggregate into a summary table in parallel
CREATE TABLE PROJECT_EXPENSE_SUMMARY (
                                         ProjectID NUMBER PRIMARY KEY,
                                         TotalExpenses NUMBER(14,2)
);

INSERT /*+ PARALLEL(e,8) */ INTO PROJECT_EXPENSE_SUMMARY (ProjectID, TotalExpenses)
SELECT ProjectID, SUM(Amount)
FROM Expense e
GROUP BY ProjectID;

COMMIT;

-----------------------------------------------------------
-- 9.Distributed Query Optimization
-----------------------------------------------------------
-- CONNECT BranchDB_A/A_pwd
EXPLAIN PLAN FOR
SELECT a.ProjectID, a.Title, b.CrewID
FROM Project_A a
         JOIN Crew_B@DBLINK_TO_B b ON b.CrewID IS NOT NULL
WHERE a.ProjectID IN (SELECT ProjectID FROM Project_A WHERE Budget > 50000);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-----------------------------------------------------------
-- 10.Performance Benchmark & Report
-----------------------------------------------------------
--Centralized Query (Base Performance)
SET AUTOTRACE ON STATISTICS;

SELECT p.Title,
       COUNT(DISTINCT a.CrewID) AS TotalCrew,
       SUM(a.DailyRate) AS TotalRates,
       NVL(SUM(e.Amount), 0) AS TotalExpenses
FROM Project p
         LEFT JOIN Assignment a ON a.ProjectID = p.ProjectID
         LEFT JOIN Expense e ON e.ProjectID = p.ProjectID
GROUP BY p.Title
ORDER BY TotalExpenses DESC;

SET AUTOTRACE OFF;
---Parallel Query Execution
ALTER SESSION ENABLE PARALLEL QUERY;

SET AUTOTRACE ON STATISTICS;

SELECT /*+ PARALLEL(p, 8) PARALLEL(a, 8) PARALLEL(e, 8) */
    p.Title,
    COUNT(DISTINCT a.CrewID) AS TotalCrew,
    SUM(a.DailyRate) AS TotalRates,
    NVL(SUM(e.Amount), 0) AS TotalExpenses
FROM Project p
         LEFT JOIN Assignment a ON a.ProjectID = p.ProjectID
         LEFT JOIN Expense e ON e.ProjectID = p.ProjectID
GROUP BY p.Title
ORDER BY TotalExpenses DESC;

SET AUTOTRACE OFF;

SET AUTOTRACE OFF;
---Distributed Query via DB Link
SET AUTOTRACE ON STATISTICS;

SELECT p.Title,
       COUNT(DISTINCT a.CrewID) AS TotalCrew,
       NVL(SUM(e.Amount), 0) AS TotalExpenses
FROM Project_A p
         LEFT JOIN Assignment a ON a.ProjectID = p.ProjectID
         LEFT JOIN Expense@DBLINK_TO_B e ON e.ProjectID = p.ProjectID
GROUP BY p.Title
ORDER BY TotalExpenses DESC;

SET AUTOTRACE OFF;